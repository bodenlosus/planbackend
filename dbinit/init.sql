-- Auth
CREATE USER auth_admin NOINHERIT
CREATEROLE LOGIN NOREPLICATION PASSWORD 'auth' ;
CREATE SCHEMA IF NOT EXISTS auth AUTHORIZATION auth_admin ;
GRANT CREATE ON DATABASE postgres TO auth_admin ;
ALTER USER auth_admin SET search_path = auth ;

-- CREATE SCHEMA;
CREATE SCHEMA api ;

-- tables

CREATE TYPE AssetType AS ENUM ('commodity', 'crypto', 'fund', 'stock') ;

CREATE TABLE IF NOT EXISTS api.assets (
id BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
symbol TEXT NOT NULL,
name TEXT NOT NULL,
description TEXT,
asset_type AssetType NOT NULL,
last_updated DATE,
constraint AssetInfo_pkey PRIMARY KEY (id),
constraint AssetInfo_unique_symbol UNIQUE (symbol)
) ;


CREATE INDEX idx_asset_symbol ON api.assets USING HASH (symbol) ;

create table api.asset_prices (
asset_id BIGINT NOT NULL,
tstamp DATE NOT NULL,
open REAL,
close REAL,
high REAL,
low REAL,
volume BIGINT,
id BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
CONSTRAINT AssetPrices_pkey PRIMARY KEY (id),
CONSTRAINT unique_asset_timestamp UNIQUE (asset_id, tstamp),
CONSTRAINT AssetPrices_asset_id_fkey FOREIGN KEY (asset_id) REFERENCES api.assets (id)
) ;

CREATE INDEX IF NOT EXISTS idx_asset_id ON api.asset_prices (asset_id) ;

CREATE UNIQUE INDEX IF NOT EXISTS idx_asset_id_tstamp ON api.asset_prices (asset_id,
tstamp DESC) ;

CREATE INDEX IF NOT EXISTS idx_tstamp ON api.asset_prices (tstamp) ;

-- DEPOTS

CREATE SCHEMA depots ;
CREATE TABLE IF NOT EXISTS depots.depots (
created TIMESTAMP NOT NULL,
cash BIGINT NOT NULL,
users UUID [] NOT NULL,
id BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
CONSTRAINT Depots_pkey PRIMARY KEY (id)
) ;

CREATE TABLE IF NOT EXISTS depots.positions (
id BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
asset_id BIGINT NOT NULL,
amount REAL NOT NULL,
price REAL NOT NULL,
worth REAL NOT NULL,
last DATE,
depot_id BIGINT NOT NULL,
CONSTRAINT Positions_pkey PRIMARY KEY (id),
CONSTRAINT unique_depot_asset UNIQUE (depot_id, asset_id),
CONSTRAINT Positions_asset_pkey FOREIGN KEY (asset_id) REFERENCES api.assets (id),
CONSTRAINT Positions_depot_pkey FOREIGN KEY (depot_id) REFERENCES depots.depots (id)
) ;

CREATE INDEX IF NOT EXISTS idx_position_asset_depot on depots.positions (asset_id,
depot_id) ;
CREATE INDEX IF NOT EXISTS idx_position_asset on depots.positions (asset_id) ;
CREATE INDEX IF NOT EXISTS idx_position_depot on depots.positions (depot_id) ;

CREATE TABLE IF NOT EXISTS depots.transactions (
depot_id BIGINT NOT NULL,
user_id UUID,
asset_id BIGINT NOT NULL,
amount REAL NOT NULL,
price BIGINT NOT NULL,
tstamp TIMESTAMP NOT NULL DEFAULT NOW (),
commission REAL NOT NULL,
id BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
CONSTRAINT Transactions_pkey PRIMARY KEY (id),
CONSTRAINT Transactions_depot_fkey FOREIGN KEY (depot_id) REFERENCES depots.depots (id),
CONSTRAINT Transactions_stock_fkey FOREIGN KEY (asset_id) REFERENCES api.assets (id)
) ;

CREATE INDEX IF NOT EXISTS idx_transaction_assets_depot on depots.transactions (asset_id,
depot_id) ;
CREATE INDEX IF NOT EXISTS idx_transaction_asset on depots.transactions (asset_id) ;
CREATE INDEX IF NOT EXISTS idx_transaction_depot on depots.transactions (depot_id) ;

CREATE TABLE IF NOT EXISTS depots.depot_values (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  depot_id BIGINT NOT NULL,
  cash REAL,
  assets REAL,
  tstamp DATE NOT NULL DEFAULT NOW (),
  CONSTRAINT unique_depot_tstamp UNIQUE (depot_id, tstamp),
  CONSTRAINT Values_depot_fkey FOREIGN KEY (depot_id) REFERENCES depots.depots (id)
);

CREATE INDEX IF NOT EXISTS idx_values_depot ON depots.values (depot_id);
CREATE INDEX IF NOT EXISTS idx_values_tstamp ON depots.values (tstamp);

CREATE OR REPLACE VIEW depots.aggregated_values AS
WITH latest_per_depot AS (
    SELECT
        depot_id,
        cash,
        assets,
        cash + assets as total,
        tstamp,
        NTH_VALUE(cash + assets, 2) OVER (
            PARTITION BY depot_id 
            ORDER BY tstamp DESC 
            ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
        ) as prev_1d_total,
        NTH_VALUE(cash + assets, 23) OVER (
            PARTITION BY depot_id 
            ORDER BY tstamp DESC 
            ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
        ) as prev_1m_total,
        NTH_VALUE(cash + assets, 253) OVER (
            PARTITION BY depot_id 
            ORDER BY tstamp DESC 
            ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
        ) as prev_1y_total,
        ROW_NUMBER() OVER (PARTITION BY depot_id ORDER BY tstamp DESC) as rn
    FROM depots.values
)
SELECT
    depot_id,
    cash,
    assets,
    total,
    tstamp,
    prev_1d_total,
    prev_1m_total,
    prev_1y_total,
    -- Bonus: calculated differences if you want them
    total - prev_1d_total as diff_1d,
    total - prev_1m_total as diff_1m,
    total - prev_1y_total as diff_1y,
    (total - prev_1d_total) / NULLIF(prev_1d_total, 0) * 100 as rel_diff_1d,
    (total - prev_1m_total) / NULLIF(prev_1m_total, 0) * 100 as rel_diff_1m,
    (total - prev_1y_total) / NULLIF(prev_1y_total, 0) * 100 as rel_diff_1y
FROM latest_per_depot
WHERE rn = 1;

-- auth and roles
CREATE ROLE anon NOINHERIT NOLOGIN ;


ALTER TABLE api.assets ENABLE ROW LEVEL SECURITY ;
ALTER TABLE api.asset_prices ENABLE ROW LEVEL SECURITY ;

ALTER ROLE anon SET search_path = api ;

CREATE MATERIALIZED VIEW IF NOT EXISTS depots.position_profits AS
WITH position_summary AS (
    SELECT
        depot_id,
        asset_id,
        SUM(amount) as current_amount,
        SUM(CASE WHEN amount > 0 THEN amount * price + commission ELSE 0 END) as total_invested,
        SUM(CASE WHEN amount < 0 THEN ABS(amount * price) - commission ELSE 0 END) as total_sold
    FROM depots.transactions 
    GROUP BY depot_id, asset_id 
    HAVING SUM(amount) > 0  -- Only active positions
),
latest_prices AS (
    SELECT DISTINCT ON (asset_id)
        asset_id,
        close as current_price
    FROM api.asset_prices 
    ORDER BY asset_id, tstamp DESC
)
SELECT 
    ps.depot_id,
    ps.asset_id,
    a.symbol,
    ps.current_amount,
    ps.total_invested,
    ps.total_sold,
    lp.current_price,
    ps.current_amount * lp.current_price as market_value,
    -- Total profit
    ps.total_sold + (ps.current_amount * lp.current_price) - ps.total_invested as total_profit
FROM position_summary ps
JOIN api.assets a ON ps.asset_id = a.id
LEFT JOIN latest_prices lp ON ps.asset_id = lp.asset_id;

CREATE UNIQUE INDEX idx_position_profits_unique 
ON depots.position_profits (depot_id, asset_id);


CREATE OR REPLACE FUNCTION refresh_position_profits()
RETURNS TRIGGER AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY depots.position_profits;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_refresh_position_profits_transactions
    AFTER INSERT OR UPDATE OR DELETE ON depots.transactions
    FOR EACH STATEMENT
    EXECUTE FUNCTION refresh_position_profits();


CREATE TRIGGER trigger_refresh_position_profits_prices
    AFTER INSERT OR UPDATE OR DELETE ON api.asset_prices
    FOR EACH STATEMENT
    EXECUTE FUNCTION refresh_position_profits();
-- Pooler

CREATE ROLE authenticator NOINHERIT LOGIN PASSWORD 'auth' ;
GRANT CONNECT ON DATABASE postgres TO authenticator ;

GRANT anon TO authenticator ;

-- Service Rest
CREATE ROLE service_worker NOINHERIT BYPASSRLS LOGIN PASSWORD 'service' ;
GRANT CONNECT ON DATABASE postgres TO service_worker ;


GRANT USAGE ON SCHEMA api TO service_worker ;
GRANT SELECT, UPDATE, INSERT, DELETE ON api.assets TO service_worker ;
GRANT SELECT, UPDATE, INSERT, DELETE ON api.asset_prices TO service_worker ;

GRANT USAGE ON SEQUENCE api.assets_id_seq TO service_worker ;
GRANT USAGE ON SEQUENCE api.asset_prices_id_seq TO service_worker ;

GRANT USAGE ON SCHEMA depots TO service_worker ;
GRANT SELECT, UPDATE, INSERT, DELETE ON depots.depots TO service_worker ;
GRANT SELECT, UPDATE, INSERT, DELETE ON depots.positions TO service_worker ;
GRANT SELECT, UPDATE, INSERT, DELETE ON depots.transactions TO service_worker ;

GRANT USAGE ON SEQUENCE depots.depots_id_seq TO service_worker ;
GRANT USAGE ON SEQUENCE depots.positions_id_seq TO service_worker ;
GRANT USAGE ON SEQUENCE depots.transactions_id_seq TO service_worker ;
GRANT USAGE ON SEQUENCE depots.values_id_seq TO service_worker ;

CREATE ROLE authenticated NOINHERIT NOLOGIN ;
