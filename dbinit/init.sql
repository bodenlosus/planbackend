

-- Auth
CREATE USER auth_admin NOINHERIT CREATEROLE LOGIN NOREPLICATION PASSWORD 'auth';
CREATE SCHEMA IF NOT EXISTS auth AUTHORIZATION auth_admin;

GRANT CREATE ON DATABASE postgres TO auth_admin;

ALTER USER auth_admin SET search_path = auth;

-- CREATE SCHEMA;
CREATE SCHEMA api;

-- tables
CREATE TYPE AssetType AS ENUM (
  'commodity',
  'crypto',
  'fund',
  'stock'
);

CREATE TABLE IF NOT EXISTS api.assets (
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  symbol text NOT NULL,
  name text NOT NULL,
  description text,
  asset_type AssetType NOT NULL,
  last_updated date,
  CONSTRAINT AssetInfo_pkey PRIMARY KEY (id),
  CONSTRAINT AssetInfo_unique_symbol UNIQUE (symbol)
);

CREATE INDEX idx_asset_symbol ON api.assets USING HASH (symbol);

CREATE TABLE api.asset_prices (
  asset_id bigint NOT NULL,
  tstamp date NOT NULL,
  open REAL,
  close REAL,
  high real,
  low real,
  volume bigint,
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  CONSTRAINT AssetPrices_pkey PRIMARY KEY (id),
  CONSTRAINT unique_asset_timestamp UNIQUE (asset_id, tstamp),
  CONSTRAINT AssetPrices_asset_id_fkey FOREIGN KEY (asset_id) REFERENCES api.assets (id)
);

CREATE INDEX IF NOT EXISTS idx_asset_id ON api.asset_prices (asset_id);

CREATE UNIQUE INDEX IF NOT EXISTS idx_asset_id_tstamp ON api.asset_prices (asset_id, tstamp DESC);

CREATE INDEX IF NOT EXISTS idx_tstamp ON api.asset_prices (tstamp);

-- DEPOTS
CREATE SCHEMA depots;

CREATE TABLE IF NOT EXISTS depots.depots (
  created timestamp NOT NULL,
  cash bigint NOT NULL,
  cash_start bigint NOT NULL,
  users uuid[] NOT NULL,
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  CONSTRAINT Depots_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS depots.positions (
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  asset_id bigint NOT NULL,
  amount real NOT NULL,
  price real NOT NULL,
  worth real NOT NULL,
  last DATE,
  depot_id bigint NOT NULL,
  CONSTRAINT Positions_pkey PRIMARY KEY (id),
  CONSTRAINT unique_depot_asset UNIQUE (depot_id, asset_id),
  CONSTRAINT Positions_asset_pkey FOREIGN KEY (asset_id) REFERENCES api.assets (id),
  CONSTRAINT Positions_depot_pkey FOREIGN KEY (depot_id) REFERENCES depots.depots (id)
);

CREATE INDEX IF NOT EXISTS idx_position_asset_depot ON depots.positions (asset_id, depot_id);

CREATE INDEX IF NOT EXISTS idx_position_asset ON depots.positions (asset_id);

CREATE INDEX IF NOT EXISTS idx_position_depot ON depots.positions (depot_id);

CREATE TABLE IF NOT EXISTS depots.transactions (
  depot_id bigint NOT NULL,
  user_id uuid,
  asset_id bigint NOT NULL,
  amount real NOT NULL,
  price real NOT NULL,
  tstamp timestamp NOT NULL DEFAULT NOW(),
  commission real NOT NULL,
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  CONSTRAINT Transactions_pkey PRIMARY KEY (id),
  CONSTRAINT Transactions_depot_fkey FOREIGN KEY (depot_id) REFERENCES depots.depots (id),
  CONSTRAINT Transactions_stock_fkey FOREIGN KEY (asset_id) REFERENCES api.assets (id)
);

CREATE INDEX IF NOT EXISTS idx_transaction_assets_depot ON depots.transactions (asset_id, depot_id);

CREATE INDEX IF NOT EXISTS idx_transaction_asset ON depots.transactions (asset_id);

CREATE INDEX IF NOT EXISTS idx_transaction_depot ON depots.transactions (depot_id);

CREATE OR REPLACE VIEW depots.aggregated_transactions AS
WITH daily_totals AS (
  SELECT
    transactions.depot_id,
    transactions.asset_id,
    date(transactions.tstamp) AS tstamp,
    sum(transactions.amount * transactions.price) AS daily_expenses,
    sum(transactions.amount) AS daily_amount,
    sum(transactions.commission) AS daily_commission
  FROM
    depots.transactions
  GROUP BY
    transactions.depot_id,
    transactions.asset_id,
    (date(transactions.tstamp)))
SELECT
  depot_id,
  asset_id,
  tstamp,
  daily_amount,
  daily_commission,
  sum(daily_expenses) OVER (PARTITION BY depot_id, asset_id ORDER BY tstamp) AS running_expenses,
  sum(daily_amount) OVER (PARTITION BY depot_id, asset_id ORDER BY tstamp) AS running_amount,
  sum(daily_commission) OVER (PARTITION BY depot_id, asset_id ORDER BY tstamp) AS running_commission
  FROM
    daily_totals
  ORDER BY
    depot_id,
    asset_id,
    tstamp;


CREATE OR REPLACE VIEW depots.values AS
SELECT
  t.depot_id,
  ap.tstamp,
  d.cash_start + SUM(COALESCE(t.running_amount, 0) * ap.close - COALESCE(t.running_commission, 0) - COALESCE(t.running_expenses)) AS value,
  d.cash_start - SUM(COALESCE(t.running_commission, 0) + COALESCE(t.running_expenses)) AS cash,
  SUM(COALESCE(t.running_amount, 0) * ap.close - COALESCE(t.running_commission, 0) - COALESCE(t.running_expenses)) AS profit_from_start,
  SUM(COALESCE(t.running_amount, 0) * ap.close) AS assets
FROM
  api.asset_prices ap
INNER JOIN LATERAL (
  SELECT
    *
  FROM
    depots.aggregated_transactions t
  WHERE
    t.asset_id = ap.asset_id
    AND t.tstamp <= ap.tstamp
  ORDER BY
    t.tstamp DESC
    LIMIT 1) t ON TRUE
LEFT JOIN depots.depots d ON t.depot_id = d.id
WHERE
  t.depot_id IS NOT NULL -- optional, but keeps it clean
GROUP BY
  t.depot_id,
  ap.tstamp,
  d.cash_start
ORDER BY
  t.depot_id,
  ap.tstamp;

CREATE OR REPLACE VIEW depots.aggregated_values AS
WITH latest_per_depot AS (
  SELECT
    assets,
    depot_id,
    cash,
    profit_from_start,
    value as total,
    tstamp,
    NTH_VALUE(value, 2) OVER (PARTITION BY depot_id ORDER BY tstamp DESC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS prev_1d_total,
    NTH_VALUE(value, 23) OVER (PARTITION BY depot_id ORDER BY tstamp DESC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS prev_1m_total,
    NTH_VALUE(value, 253) OVER (ORDER BY tstamp DESC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS prev_1y_total,
    ROW_NUMBER() OVER (PARTITION BY depot_id ORDER BY tstamp DESC) AS rn
  FROM
    depots.values
)
SELECT
  assets,
  depot_id,
  cash,
  total,
  profit_from_start
  tstamp,
  prev_1d_total,
  prev_1m_total,
  prev_1y_total,
  -- Bonus: calculated differences if you want them
  total - prev_1d_total AS diff_1d,
  total - prev_1m_total AS diff_1m,
  total - prev_1y_total AS diff_1y,
  (total - prev_1d_total) / NULLIF (prev_1d_total, 0) * 100 AS rel_diff_1d,
  (total - prev_1m_total) / NULLIF (prev_1m_total, 0) * 100 AS rel_diff_1m,
  (total - prev_1y_total) / NULLIF (prev_1y_total, 0) * 100 AS rel_diff_1y
FROM
  latest_per_depot
WHERE
  rn = 1;

-- auth and roles
CREATE ROLE anon NOINHERIT NOLOGIN;

ALTER TABLE api.assets ENABLE ROW LEVEL SECURITY;

ALTER TABLE api.asset_prices ENABLE ROW LEVEL SECURITY;

ALTER ROLE anon SET search_path = api;

CREATE OR REPLACE VIEW depots.position_profits AS
WITH position_summary AS (
  SELECT
    depot_id,
    asset_id,
    SUM(amount) AS current_amount,
    SUM(
      CASE WHEN amount > 0 THEN
        amount * price + commission
      ELSE
        0
      END) AS total_invested,
    SUM(
      CASE WHEN amount < 0 THEN
        ABS(amount * price) - commission
      ELSE
        0
      END) AS total_sold
  FROM
    depots.transactions
  GROUP BY
    depot_id,
    asset_id
  HAVING
    SUM(amount) > 0 -- Only active positions
),
latest_prices AS (
  SELECT DISTINCT ON (asset_id)
    asset_id,
    CLOSE AS current_price
  FROM
    api.asset_prices
  ORDER BY
    asset_id,
    tstamp DESC
)
SELECT
  ps.depot_id,
  ps.asset_id,
  a.symbol,
  ps.current_amount,
  ps.total_invested,
  ps.total_sold,
  lp.current_price,
  ps.current_amount * lp.current_price AS market_value,

  -- Total profit
  ps.total_sold + (ps.current_amount * lp.current_price) - ps.total_invested AS total_profit
FROM
  position_summary ps
  JOIN api.assets a ON ps.asset_id = a.id
  LEFT JOIN latest_prices lp ON ps.asset_id = lp.asset_id;

-- CREATE UNIQUE INDEX idx_position_profits_unique ON depots.position_profits (depot_id, asset_id);

-- currently not done due to it requiring proper permission handling
-- CREATE OR REPLACE FUNCTION refresh_position_profits ()
--   RETURNS TRIGGER
--   AS $$
-- BEGIN
--   REFRESH MATERIALIZED VIEW CONCURRENTLY depots.position_profits;
--   RETURN NULL;
-- END;
-- $$
-- LANGUAGE plpgsql;

-- CREATE TRIGGER trigger_refresh_position_profits_transactions
--   AFTER INSERT OR UPDATE OR DELETE ON depots.transactions
--   FOR EACH STATEMENT
--   EXECUTE FUNCTION refresh_position_profits ();

-- CREATE TRIGGER trigger_refresh_position_profits_prices
--   AFTER INSERT OR UPDATE OR DELETE ON api.asset_prices
--   FOR EACH STATEMENT
--   EXECUTE FUNCTION refresh_position_profits ();

-- Pooler
CREATE ROLE authenticator NOINHERIT LOGIN PASSWORD 'auth';

GRANT CONNECT ON DATABASE postgres TO authenticator;

GRANT anon TO authenticator;


GRANT USAGE ON SCHEMA depots TO authenticator;
GRANT SELECT ON depots.depots TO authenticator;
-- Service Rest
CREATE ROLE service_worker NOINHERIT BYPASSRLS LOGIN PASSWORD 'service';

GRANT CONNECT ON DATABASE postgres TO service_worker;

GRANT USAGE ON SCHEMA api TO service_worker;

GRANT SELECT, UPDATE, INSERT, DELETE ON api.assets TO service_worker;

GRANT SELECT, UPDATE, INSERT, DELETE ON api.asset_prices TO service_worker;

GRANT USAGE ON SEQUENCE api.assets_id_seq
  TO service_worker;

GRANT USAGE ON SEQUENCE api.asset_prices_id_seq
  TO service_worker;

GRANT USAGE ON SCHEMA depots TO service_worker;

GRANT SELECT, UPDATE, INSERT, DELETE ON depots.depots TO service_worker;

GRANT SELECT, UPDATE, INSERT, DELETE ON depots.positions TO service_worker;

GRANT SELECT, UPDATE, INSERT, DELETE ON depots.transactions TO service_worker;

GRANT USAGE ON SEQUENCE depots.depots_id_seq
  TO service_worker;

GRANT USAGE ON SEQUENCE depots.positions_id_seq
  TO service_worker;

GRANT USAGE ON SEQUENCE depots.transactions_id_seq
  TO service_worker;

CREATE ROLE authenticated NOINHERIT NOLOGIN;

GRANT authenticated TO authenticator;


-- Enable pg_trgm extension if not already enabled
CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS assets_symbol_trgm_idx ON api.assets USING GIN (symbol gin_trgm_ops);
CREATE INDEX IF NOT EXISTS assets_name_trgm_idx ON api.assets USING GIN (name gin_trgm_ops);
CREATE INDEX IF NOT EXISTS assets_description_trgm_idx ON api.assets USING GIN (description gin_trgm_ops);

-- Fuzzy search function
CREATE OR REPLACE FUNCTION api.search_assets(
  search_query text,
  asset_type_filter text DEFAULT NULL,
  result_limit integer DEFAULT 20
)
RETURNS TABLE (
  id bigint,
  symbol text,
  name text,
  description text,
  asset_type text,
  last_updated date,
  relevance_score numeric
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    a.id,
    a.symbol,
    a.name,
    a.description,
    a.asset_type::text,
    a.last_updated,
    -- Calculate relevance score (higher = better match)
    ROUND(
      CAST(
        -- Exact matches get highest score
        CASE WHEN LOWER(a.symbol) = LOWER(search_query) THEN 100
             WHEN LOWER(a.name) = LOWER(search_query) THEN 95
             ELSE 0 
        END +
        -- Starts-with matches get high score
        CASE WHEN LOWER(a.symbol) LIKE LOWER(search_query) || '%' THEN 50
             WHEN LOWER(a.name) LIKE LOWER(search_query) || '%' THEN 45
             ELSE 0
        END +
        -- Trigram similarity scores (0-1 range, multiply for weighting)
        similarity(a.symbol, search_query) * 40 +
        similarity(a.name, search_query) * 35 +
        COALESCE(similarity(a.description, search_query) * 15, 0) +
        -- Contains match bonus
        CASE WHEN LOWER(a.symbol) LIKE '%' || LOWER(search_query) || '%' THEN 10
             WHEN LOWER(a.name) LIKE '%' || LOWER(search_query) || '%' THEN 8
             ELSE 0
        END
      AS numeric), 2
    ) as relevance_score
  FROM api.assets a
  WHERE 
    -- Fuzzy match using trigram similarity OR contains
    (
      a.symbol % search_query OR
      a.name % search_query OR
      a.description % search_query OR
      LOWER(a.symbol) LIKE '%' || LOWER(search_query) || '%' OR
      LOWER(a.name) LIKE '%' || LOWER(search_query) || '%' OR
      LOWER(a.description) LIKE '%' || LOWER(search_query) || '%'
    )
    -- Optional asset type filter
    AND (asset_type_filter IS NULL OR a.asset_type::text = asset_type_filter)
  ORDER BY relevance_score DESC, a.name ASC
  LIMIT result_limit;
END;
$$ LANGUAGE plpgsql STABLE;

GRANT EXECUTE ON FUNCTION api.search_assets(text, text, integer) TO anon, authenticated;
